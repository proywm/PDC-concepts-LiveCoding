import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML

# Function to update the plot for each frame of the animation
def update_plot(ax, array, requests, shelf_texts, table_texts, shelf_boxes, table_boxes, current_index=None, action_text=None):
    for text, box in zip(shelf_texts, shelf_boxes):
        box.set_edgecolor('b')  # Reset color to blue
        text.set_color('black')

    for text, box in zip(table_texts, table_boxes):
        box.set_edgecolor('gray')  # Reset color to gray
        text.set_text('')  # Clear text

    for i, book in enumerate(requests):
        table_texts[i].set_text(book)
        table_boxes[i].set_edgecolor('b')

    if current_index is not None:
        shelf_boxes[current_index].set_edgecolor('r')
        shelf_texts[current_index].set_color('red')

    if action_text:
        ax.set_title(action_text, fontsize=16)

    plt.draw()

# Function to handle the book requests and yield control after each action
def handle_requests(ax, array, requests, table, max_table_size):
    actions = []
    for book in requests:
        if book in table:
            actions.append((array, f"Book {book} is already on the table", None))
        else:
            if len(table) < max_table_size:
                table.append(book)
                actions.append((array, f"Fetched book {book} from shelf to table", list(array).index(book)))
            else:
                evicted_book = table.pop(0)
                table.append(book)
                actions.append((array, f"Evicted book {evicted_book} from table to shelf, fetched book {book}", list(array).index(book)))
        yield array, table, requests, None, actions[-1][1]
    yield array, table, requests, None, "All requests processed"

# Function to visualize the fetching process
def visualize_fetching(array, requests):
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.set_xlim(-1, max(len(array), 3) + 1)
    ax.set_ylim(-3, 3)
    ax.axis('off')

    shelf_texts = []
    table_texts = []
    shelf_boxes = []
    table_boxes = []

    # Add Bookshelf label
    ax.text(-0.5, 0.5, 'Bookshelf', ha='center', va='center', fontsize=14, fontweight='bold')

    for i, num in enumerate(array):
        shelf_text = ax.text(i + 0.5, 0.5, str(num), ha='center', va='center', fontsize=12, bbox=dict(facecolor='white', edgecolor='b'))
        shelf_box = plt.Rectangle((i, 0), 1, 1, fill=None, edgecolor='b')
        ax.add_patch(shelf_box)
        shelf_texts.append(shelf_text)
        shelf_boxes.append(shelf_box)

    # Add Table label
    ax.text(-0.5, -1.5, 'Table', ha='center', va='center', fontsize=14, fontweight='bold')

    for i in range(3):
        table_text = ax.text(i + 0.5, -1.5, "", ha='center', va='center', fontsize=12, bbox=dict(facecolor='white', edgecolor='gray'))
        table_box = plt.Rectangle((i, -2), 1, 1, fill=None, edgecolor='gray')
        ax.add_patch(table_box)
        table_texts.append(table_text)
        table_boxes.append(table_box)

    table = []
    max_table_size = 3

    def animate(data):
        array, table, requests, current_index, action_text = data
        update_plot(ax, array, table, shelf_texts, table_texts, shelf_boxes, table_boxes, current_index, action_text)

    ani = FuncAnimation(fig, animate, frames=handle_requests(ax, array, requests, table, max_table_size), interval=1000, repeat=False)
    plt.close(fig)
    return ani

# Function to handle the button click event
def on_button_click(b):
    clear_output(wait=True)
    array = np.random.randint(1, 100, size=10)
    requests = list(np.random.choice(array, size=5, replace=True))
    print("Book requests over time:", requests)
    ani = visualize_fetching(array, requests)
    display(HTML(ani.to_jshtml()))
    print("Books on shelf:", array)

# Create a button to trigger the visualization
button = widgets.Button(description="Visualize Fetching")
button.on_click(on_button_click)

display(button)
